function [W_LCMV,W_CBF,handle_ConformalArray,estObj_LCMV,estObj_CBF] = f_conventionalBF(problem,conf,candSet)
    % Restrict sub-arrays to Localized for LCMV
    problem.arrayRestriction = 'Localized';
    % Compute number of sub-arrays to assign per user. We ensure each user
    % receives one array and locate them horizontaly
    problem.NySubarrays = problem.nUsers;
    problem.NxSubarrays = 1;
    problem.N_Subarrays = problem.NxSubarrays*problem.NySubarrays;
    problem = o_compute_antennas_per_user(problem,candSet);
    % Create subarray partition
    problem = o_create_subarray_partition(problem);
    totSubArrays = (problem.NxSubarrays * problem.NySubarrays) / problem.nUsers;
    problem.NzPatch = problem.NxPatch;
    problem.dz = problem.dx;
    problem.handle_Ant = phased.CosineAntennaElement('FrequencyRange',...
                            [problem.freq-(problem.Bw/2) problem.freq+(problem.Bw/2)],...
                            'CosinePower',[1.5 2.5]); % [1.5 2.5] values set porque si
    handle_ConformalArray = phased.URA([problem.NyPatch,problem.NzPatch],...
                              'Lattice','Rectangular','Element',problem.handle_Ant,...
                              'ElementSpacing',[problem.dy,problem.dz]);
    problem.possible_locations = handle_ConformalArray.getElementPosition;
    
    % Antennas assigned to each user (fixed)
    mySubArray = (1:1:(problem.NxSubarrays * problem.NySubarrays));
    relevant_positions = cell(problem.nUsers,1);
    for valID = 1:problem.nUsers
        partAssignation = mySubArray(1:totSubArrays);
        temp = [];
        for ass = partAssignation
            temp = [temp problem.Partition{ass}];  %#ok<AGROW>
        end
        relevant_positions{valID} = temp;
        mySubArray(mySubArray==partAssignation) = [];  % delete assigned antennas
    end
    
    % Compute weights (beamforming)
    PhiTheta = ([-problem.phiUsers ; -problem.thetaUsers]);
    W_LCMV = zeros(problem.nUsers, problem.NxPatch*problem.NyPatch);
    W_CBF = zeros(problem.nUsers, problem.NxPatch*problem.NyPatch);
    for id = 1:problem.nUsers
        Nant_user = length(relevant_positions{id});
        % Convert antenna ID's into physical locations
        elementPos = [problem.possible_locations(1,relevant_positions{id});...
                      problem.possible_locations(2,relevant_positions{id});...
                      problem.possible_locations(3,relevant_positions{id})];
        elementPosNorm = elementPos./problem.lambda;
        
        % Apply LCMV Beamformer for selected user
        sv = steervec(elementPosNorm,PhiTheta);
        Sn = eye(Nant_user);
        resp = zeros(problem.nUsers,1) + eps;
        resp(id) = 1;  % Maximum restricted to limit (33dB)
        w_lcmv = lcmvweights(sv,resp,Sn);  % LCMV Beamformer method
        
        % Apply Convencional Beamformer for selected user
        w_cbf = cbfweights(elementPosNorm,PhiTheta(:,id));  % conventional beamformer
        
        % Store results in global W
        W_LCMV(id,relevant_positions{id}) = w_lcmv.';
        W_CBF(id,relevant_positions{id}) = w_cbf.';
    end
    
    % Extract Directivities
    [DirOKLCMVTot,DirNOKLCMVTot]  = f_BF_results(W_LCMV,handle_ConformalArray,problem,conf,false);
    [DirOKCBFTot,DirNOKCBFTot]  = f_BF_results(W_LCMV,handle_ConformalArray,problem,conf,false);
    
    % Compute basic parameters for SINR and Capacity computations
    chLoss_lin = ((problem.lambda ./ (4*pi*problem.dUsers(1:problem.nUsers))).^2).';  % Losses
    Noise_lin = db2pow(problem.Noise);  % Noise power
    Noise_lin = repmat(Noise_lin,problem.nUsers,1);
    
    % Parse results for specific case - LCMV
    DirOKLCMV_lin = db2pow(DirOKLCMVTot);
    DirNOKLCMV_lin = db2pow(DirNOKLCMVTot);
    DirNOKLCMV_gntd_lin = sum(DirNOKLCMV_lin,1).'; % Generated interference 
    DirNOKLCMV_pcvd_lin = sum(DirNOKLCMV_lin,2); % Perceived interference
    DirOKLCMV = pow2db(DirOKLCMV_lin);  %#ok  % Directivity generated to intended user (LCMV)
    DirNOKLCMV_gntd = pow2db(DirNOKLCMV_gntd_lin);  %#ok  % Directivity being generated by intended user (LCMV)
    DirNOKLCMV_pcvd = pow2db(DirNOKLCMV_pcvd_lin);  %#ok  % Directivity inflicted to intended user (LCMV)
    % Parse results for specific case - CBF (Conventional)
	DirOKCBF_lin = db2pow(DirOKCBFTot);
    DirNOKCBF_lin = db2pow(DirNOKCBFTot);
    DirNOKCBF_gntd_lin = sum(DirNOKCBF_lin,1).'; % Generated interference 
    DirNOKCBF_pcvd_lin = sum(DirNOKCBF_lin,2); % Perceived interference
    DirOKCBF = pow2db(DirOKCBF_lin);  %#ok  % Directivity generated to intended user (Conventional)
    DirNOKCBF_gntd = pow2db(DirNOKCBF_gntd_lin);  %#ok  % Directivity being generated by intended user (Conventional)
    DirNOKCBF_pcvd = pow2db(DirNOKCBF_pcvd_lin);  %#ok  % Directivity inflicted to intended user (Conventional)
    % Compute SINR and Capacities - LCMV
    SINRLCMV_PB_lin = (DirOKLCMV_lin.*chLoss_lin) ./(DirNOKLCMV_gntd_lin.*chLoss_lin + Noise_lin);
    SINRLCMV_PB = pow2db(SINRLCMV_PB_lin);  % Compute SINR Pass-Band (BB)
    Cap_LCMV = log2(1 + SINRLCMV_PB_lin);  % Compute final Capacity (bits/Hz/s)
    % Compute SINR and Capacities - CBF (Conventional)
    SINRCBF_PB_lin = (DirOKCBF_lin.*chLoss_lin) ./(DirNOKCBF_gntd_lin.*chLoss_lin + Noise_lin);
    SINRCBF_PB = pow2db(SINRCBF_PB_lin);  % Compute SINR Pass-Band (BB)
    Cap_CBF = log2(1 + SINRCBF_PB_lin);  % Compute final Capacity (bits/Hz/s)
    
    if conf.MinObjFIsSNR
        estObj_LCMV = SINRLCMV_PB;
        estObj_CBF = SINRCBF_PB;
    else
        estObj_LCMV = Cap_LCMV;
        estObj_CBF = Cap_CBF;
    end
end